import socket

# Создаем сокет через конструктор socket()
sock = socket.socket()
# Связываем созданный сокет с номер порта при помощи метода bind
# данный метод принимает один аргумент - кортеж из двух элементов:
# первый элемент кортежа - имя сетевого адаптера (если имя - пустая строка, то сокет доступен для всех сетевых интерфейсов),
# второй - номер порта
sock.bind(('', 9090))

# с помощью метода listen запускаем режим прослушивания для данного сокета.
# Метод принимает максимальное количество подключений в очереди
sock.listen(1)

# Теперь можно принять входящее подключение с помощью метода accept,
# который возвращает кортеж с двумя элементами: новый сокет (объект подключения) и адрес клиента.
# Именно этот новый сокет будет использоваться для приема и посылки клиенту данных
# Это блокирующая операция - в момент выполнения выполнение программы приостановится
# и она будет ждать входящего подключения
conn, addr = sock.accept()

# Объект conn будет использоваться для общения с клиентом
# Переменная addr - это кортеж из двух элементов - адреса клиента и его исходящего порта

# Так мы установили с клиентом связь и можем с ним общаться. Чтобы получить данные, нужно воспользоваться методом recv,
# который в каачестве аргумента принимает количество байт для чтения. Мы будем читать из сокета 1024 байт (1 Кб)
# data = conn.recv(1024)
# conn.send(data.upper())

# Следует обратить внимание, что прием и отправка сообщения происходит через объект conn, а не sock. Объект conn - это подключение к конкретному клиенту.
# Это особенность работы именно TCP-сокетов, при использовании протокола UDP все происходит по-другому

# Также при чтении необходимо указать объем читаемых данных - это обязательный параметр
# Это особенность потокового механизма передачи данных через сокеты - нельзя прочитать сообщения от клиента "целиком",
# ведь клиент может присылать в сокет данные порциями - в произвольный момент времени произвольной длины.
# В сокете, а точнее во входящем потоке, все эти сообщения "склеются" и будут представлены единым байтовым массивом

# Поэтому можно организовать бесконечный цикл, в котором читать данные какой-то определенной длины и каждый раз проверять, получили ли мы что-то или нет
while True:
    data = conn.recv(1024)
    if not data:
        break
    conn.send(data.upper())
# Данная конструкция работает по то причине, что клиент закрывает свое соединение, как только передал все данные.
# В таком случае на сервере метод recv возвращает пустое значение. Это сигнал завершения передачи

# Метод recv тоже является блокирующей операцией, он разблокируется в двух случаях:
# 1) Когда клиент передал необходимый объем данных;
# 2) Когда клиент закрыл соединение.

# Также в данном примере сервер посылает обратно те же данные, что и получил, клиенто с помощью метода send()
# Этот метод посылает данные через сокет - это неблокирующая операция, так как данные посылаются тут же и не нужно ничего ждать
# Реальные сервера посылают в ответ какую-либо диагностическую информацию, например, ответы на его запросы.
# Текущая реализация сервера - это, так называемый, "эхо-сервер"

# После получения порции данных и отсылки их обратно можно закрыть соединеня серверного сокета
conn.close()
